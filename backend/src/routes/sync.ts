{
  "backend/src/routes/apartments.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', async (_req, res, next) => {\n  try {\n    const result = await query('SELECT * FROM apartment_complex WHERE is_active = true ORDER BY name');\n    res.json({ apartments: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/:id', async (req, res, next): Promise<any> => {\n  try {\n    const result = await query('SELECT * FROM apartment_complex WHERE id = $1', [req.params.id]);\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Apartment complex not found' });\n    }\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', authorize('admin', 'manager'), async (req, res, next) => {\n  try {\n    const { name, address, totalUnits, contactName, contactPhone, contactEmail } = req.body;\n    const result = await query(\n      'INSERT INTO apartment_complex (name, address, total_units, contact_name, contact_phone, contact_email) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',\n      [name, address, totalUnits, contactName, contactPhone, contactEmail]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/auth.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\nimport { config } from '../config';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\n\n// Login\nrouter.post('/login', async (req, res, next): Promise<any> => {\n  try {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.status(400).json({ error: 'Email and password required' });\n    }\n\n    const result = await query(\n      'SELECT id, email, password_hash, first_name, last_name, role, location_id, is_active FROM \"user\" WHERE email = $1',\n      [email]\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const user = result.rows[0];\n\n    if (!user.is_active) {\n      return res.status(403).json({ error: 'Account is inactive' });\n    }\n\n    const isValid = await bcrypt.compare(password, user.password_hash);\n\n    if (!isValid) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    const token = jwt.sign(\n      {\n        id: user.id,\n        email: user.email,\n        role: user.role,\n        locationId: user.location_id,\n      },\n      config.jwt.secret,\n      { expiresIn: config.jwt.expiresIn }\n    );\n\n    // Update last login\n    await query('UPDATE \"user\" SET last_login = CURRENT_TIMESTAMP WHERE id = $1', [user.id]);\n\n    res.json({\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        firstName: user.first_name,\n        lastName: user.last_name,\n        role: user.role,\n        locationId: user.location_id,\n      },\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get current user\nrouter.get('/me', authenticate, async (req: any, res, next): Promise<any> => {\n  try {\n    const result = await query(\n      'SELECT id, email, first_name, last_name, role, location_id, is_active FROM \"user\" WHERE id = $1',\n      [req.user.id]\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    const user = result.rows[0];\n\n    res.json({\n      id: user.id,\n      email: user.email,\n      firstName: user.first_name,\n      lastName: user.last_name,\n      role: user.role,\n      locationId: user.location_id,\n      isActive: user.is_active,\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/clients.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', async (_req, res, next) => {\n  try {\n    const result = await query('SELECT * FROM client WHERE is_active = true ORDER BY name');\n    res.json({ clients: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', authorize('admin', 'manager'), async (req, res, next) => {\n  try {\n    const { name, contactName, contactPhone, contactEmail, address, paymentTerms } = req.body;\n    const result = await query(\n      'INSERT INTO client (name, contact_name, contact_phone, contact_email, address, payment_terms) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',\n      [name, contactName, contactPhone, contactEmail, address, paymentTerms]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/inventory.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\n// Get inventory status\nrouter.get('/', async (req: any, res, next) => {\n  try {\n    const { locationId } = req.query;\n\n    let queryText = 'SELECT * FROM v_inventory_status WHERE 1=1';\n    const params: any[] = [];\n\n    if (locationId) {\n      params.push(locationId);\n      queryText += ' AND location_id = $1';\n    } else if (req.user.role !== 'admin' && req.user.locationId) {\n      params.push(req.user.locationId);\n      queryText += ' AND location_id = $1';\n    }\n\n    queryText += ' ORDER BY location_name, material_category';\n\n    const result = await query(queryText, params);\n\n    res.json({ inventory: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get inventory by location and material\nrouter.get('/:locationId/:materialId', async (req, res, next): Promise<any> => {\n  try {\n    const result = await query(\n      'SELECT * FROM inventory WHERE location_id = $1 AND material_category_id = $2',\n      [req.params.locationId, req.params.materialId]\n    );\n\n    if (result.rows.length === 0) {\n      return res.json({ quantity_kg: 0 });\n    }\n\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/locations.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', async (_req, res, next) => {\n  try {\n    const result = await query('SELECT * FROM location WHERE is_active = true ORDER BY name');\n    res.json({ locations: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/:id', async (req, res, next): Promise<any> => {\n  try {\n    const result = await query('SELECT * FROM location WHERE id = $1', [req.params.id]);\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Location not found' });\n    }\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', authorize('admin'), async (req, res, next) => {\n  try {\n    const { coopId, name, address, phone, managerName } = req.body;\n    const result = await query(\n      'INSERT INTO location (coop_id, name, address, phone, manager_name) VALUES ($1, $2, $3, $4, $5) RETURNING *',\n      [coopId, name, address, phone, managerName]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/materials.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', async (_req, res, next) => {\n  try {\n    const result = await query('SELECT * FROM material_category WHERE is_active = true ORDER BY name');\n    res.json({ materials: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/prices', async (req, res, next) => {\n  try {\n    const { date, locationId } = req.query;\n    let queryText = 'SELECT dp.*, mc.name as material_name FROM daily_price dp JOIN material_category mc ON dp.material_category_id = mc.id WHERE date = $1';\n    const params: any[] = [date || new Date().toISOString().split('T')[0]];\n\n    if (locationId) {\n      params.push(locationId);\n      queryText += ' AND (location_id = $2 OR location_id IS NULL)';\n    } else {\n      queryText += ' AND location_id IS NULL';\n    }\n\n    const result = await query(queryText, params);\n    res.json({ prices: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/prices', authorize('admin', 'manager'), async (req: any, res, next) => {\n  try {\n    const { materialCategoryId, locationId, date, purchasePricePerKg, salePricePerKg } = req.body;\n    const result = await query(\n      `INSERT INTO daily_price (material_category_id, location_id, date, purchase_price_per_kg, sale_price_per_kg, created_by)\n       VALUES ($1, $2, $3, $4, $5, $6) \n       ON CONFLICT (material_category_id, location_id, date) \n       DO UPDATE SET purchase_price_per_kg = $4, sale_price_per_kg = $5\n       RETURNING *`,\n      [materialCategoryId, locationId, date, purchasePricePerKg, salePricePerKg, req.user.id]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/reports.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\n// Get transaction trends\nrouter.get('/trends', async (req: any, res, next) => {\n  try {\n    const { locationId, days = 30 } = req.query;\n\n    const result = await query(\n      'SELECT * FROM get_transaction_trends($1, $2)',\n      [locationId || null, days]\n    );\n\n    res.json({ trends: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get apartment summary\nrouter.get('/apartment-summary', async (req, res, next): Promise<any> => {\n  try {\n    const { apartmentId, materialName, startDate, endDate } = req.query;\n\n    if (!apartmentId || !materialName || !startDate || !endDate) {\n      return res.status(400).json({ error: 'Missing required parameters' });\n    }\n\n    const result = await query(\n      'SELECT get_apartment_material_total($1, $2, $3, $4) as total_kg',\n      [apartmentId, materialName, startDate, endDate]\n    );\n\n    res.json({ totalKg: result.rows[0].total_kg });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get weekly apartment summary\nrouter.get('/weekly-apartment', async (req, res, next) => {\n  try {\n    const { weeks = 4 } = req.query;\n\n    const result = await query(\n      `SELECT * FROM mv_weekly_apartment_summary \n       WHERE week_start >= CURRENT_DATE - INTERVAL '${weeks} weeks'\n       ORDER BY week_start DESC, apartment_name, material_category`\n    );\n\n    res.json({ summary: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get waste picker monthly summary\nrouter.get('/waste-picker-monthly', async (req, res, next) => {\n  try {\n    const { months = 3 } = req.query;\n\n    const result = await query(\n      `SELECT * FROM mv_waste_picker_monthly_summary \n       WHERE month_start >= CURRENT_DATE - INTERVAL '${months} months'\n       ORDER BY month_start DESC, waste_picker_name, material_category`\n    );\n\n    res.json({ summary: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get location daily summary\nrouter.get('/location-daily', async (req, res, next) => {\n  try {\n    const { locationId, days = 30 } = req.query;\n\n    let queryText = `SELECT * FROM mv_location_daily_summary \n                     WHERE transaction_date >= CURRENT_DATE - INTERVAL '${days} days'`;\n    const params: any[] = [];\n\n    if (locationId) {\n      params.push(locationId);\n      queryText += ' AND location_id = $1';\n    }\n\n    queryText += ' ORDER BY transaction_date DESC, location_name, material_category';\n\n    const result = await query(queryText, params);\n\n    res.json({ summary: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get pending payments\nrouter.get('/pending-payments', authorize('admin', 'manager'), async (req, res, next) => {\n  try {\n    const { locationId } = req.query;\n\n    let queryText = 'SELECT * FROM v_pending_payments WHERE 1=1';\n    const params: any[] = [];\n\n    if (locationId) {\n      params.push(locationId);\n      queryText += ' AND location_id = $1';\n    }\n\n    queryText += ' ORDER BY transaction_date, waste_picker_name';\n\n    const result = await query(queryText, params);\n\n    res.json({ payments: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/sync.ts": "import { Router } from 'express';\nimport { query, transaction } from '../db';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\n// Sync offline transactions\nrouter.post('/transactions', async (req: any, res, next): Promise<any> => {\n  try {\n    const { transactions, deviceId } = req.body;\n\n    if (!Array.isArray(transactions) || transactions.length === 0) {\n      return res.status(400).json({ error: 'Invalid transactions array' });\n    }\n\n    const results = await transaction(async (client) => {\n      const synced = [];\n      const failed = [];\n\n      for (const txn of transactions) {\n        try {\n          // Check for duplicates\n          const existing = await client.query(\n            'SELECT id FROM transaction WHERE device_id = $1 AND transaction_date = $2 AND weight_kg = $3',\n            [deviceId, txn.transactionDate, txn.weightKg]\n          );\n\n          if (existing.rows.length > 0) {\n            failed.push({ transaction: txn, error: 'Duplicate transaction' });\n            continue;\n          }\n\n          // Insert transaction\n          const result = await client.query(\n            `INSERT INTO transaction (\n              location_id, material_category_id, source_type,\n              apartment_complex_id, apartment_unit, waste_picker_id,\n              weight_kg, quality_grade, unit_price, total_cost,\n              payment_method, notes, recorded_by, device_id,\n              transaction_date, is_synced\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)\n            RETURNING id`,\n            [\n              txn.locationId, txn.materialCategoryId, txn.sourceType,\n              txn.apartmentComplexId, txn.apartmentUnit, txn.wastePickerId,\n              txn.weightKg, txn.qualityGrade, txn.unitPrice, txn.totalCost,\n              txn.paymentMethod, txn.notes, req.user.id, deviceId,\n              txn.transactionDate, true\n            ]\n          );\n\n          synced.push({ localId: txn.localId, serverId: result.rows[0].id });\n\n          // Log sync\n          await client.query(\n            'INSERT INTO sync_log (device_id, table_name, record_id, operation, sync_status, synced_at) VALUES ($1, $2, $3, $4, $5, CURRENT_TIMESTAMP)',\n            [deviceId, 'transaction', result.rows[0].id, 'insert', 'synced']\n          );\n        } catch (error: any) {\n          failed.push({ transaction: txn, error: error.message });\n        }\n      }\n\n      return { synced, failed };\n    });\n\n    res.json(results);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get pending sync items\nrouter.get('/pending', async (req, res, next): Promise<any> => {\n  try {\n    const { deviceId } = req.query;\n\n    if (!deviceId) {\n      return res.status(400).json({ error: 'Device ID required' });\n    }\n\n    const result = await query(\n      'SELECT * FROM sync_log WHERE device_id = $1 AND sync_status = $2 ORDER BY created_at',\n      [deviceId, 'pending']\n    );\n\n    res.json({ pending: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/transactions.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\n\n// All routes require authentication\nrouter.use(authenticate);\n\n// Create transaction\nrouter.post('/', authorize('admin', 'manager', 'operator'), async (req: any, res, next): Promise<any> => {\n  try {\n    const {\n      locationId,\n      materialCategoryId,\n      sourceType,\n      apartmentComplexId,\n      apartmentUnit,\n      wastePickerId,\n      weightKg,\n      qualityGrade,\n      paymentMethod,\n      notes,\n      deviceId,\n    } = req.body;\n\n    // Validation\n    if (!locationId || !materialCategoryId || !sourceType || !weightKg) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n\n    if (sourceType === 'apartment' && !apartmentComplexId) {\n      return res.status(400).json({ error: 'Apartment complex ID required for apartment source' });\n    }\n\n    if (sourceType === 'waste_picker' && !wastePickerId) {\n      return res.status(400).json({ error: 'Waste picker ID required for waste picker source' });\n    }\n\n    // Get current price\n    const priceResult = await query(\n      'SELECT get_current_price($1, $2, CURRENT_DATE, $3) as price',\n      [materialCategoryId, locationId, 'purchase']\n    );\n\n    const unitPrice = priceResult.rows[0]?.price;\n\n    if (!unitPrice) {\n      return res.status(400).json({ error: 'No price configured for this material' });\n    }\n\n    const totalCost = (parseFloat(weightKg) * parseFloat(unitPrice)).toFixed(2);\n\n    // Insert transaction\n    const result = await query(\n      `INSERT INTO transaction (\n        location_id, material_category_id, source_type,\n        apartment_complex_id, apartment_unit, waste_picker_id,\n        weight_kg, quality_grade, unit_price, total_cost,\n        payment_method, notes, recorded_by, device_id\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n      RETURNING *`,\n      [\n        locationId, materialCategoryId, sourceType,\n        apartmentComplexId, apartmentUnit, wastePickerId,\n        weightKg, qualityGrade || 'standard', unitPrice, totalCost,\n        paymentMethod, notes, req.user.id, deviceId\n      ]\n    );\n\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get transactions\nrouter.get('/', async (req: any, res, next) => {\n  try {\n    const { locationId, startDate, endDate, sourceType, limit = 50, offset = 0 } = req.query;\n\n    let queryText = 'SELECT * FROM v_transaction_details WHERE 1=1';\n    const params: any[] = [];\n    let paramCount = 1;\n\n    if (locationId) {\n      params.push(locationId);\n      queryText += ` AND location_name = (SELECT name FROM location WHERE id = $${paramCount++})`;\n    }\n\n    if (startDate) {\n      params.push(startDate);\n      queryText += ` AND transaction_date >= $${paramCount++}`;\n    }\n\n    if (endDate) {\n      params.push(endDate);\n      queryText += ` AND transaction_date <= $${paramCount++}`;\n    }\n\n    if (sourceType) {\n      params.push(sourceType);\n      queryText += ` AND source_type = $${paramCount++}`;\n    }\n\n    queryText += ' ORDER BY transaction_date DESC, created_at DESC';\n\n    params.push(limit);\n    queryText += ` LIMIT $${paramCount++}`;\n\n    params.push(offset);\n    queryText += ` OFFSET $${paramCount++}`;\n\n    const result = await query(queryText, params);\n\n    // Get total count\n    let countQuery = 'SELECT COUNT(*) FROM v_transaction_details WHERE 1=1';\n    const countParams = params.slice(0, -2); // Remove limit and offset\n\n    if (locationId) countQuery += ' AND location_name = (SELECT name FROM location WHERE id = $1)';\n    if (startDate) countQuery += ` AND transaction_date >= $${locationId ? 2 : 1}`;\n    if (endDate) countQuery += ` AND transaction_date <= $${locationId && startDate ? 3 : locationId || startDate ? 2 : 1}`;\n    if (sourceType) countQuery += ` AND source_type = $${countParams.length + 1}`;\n\n    const countResult = await query(countQuery, countParams);\n\n    res.json({\n      transactions: result.rows,\n      total: parseInt(countResult.rows[0].count),\n      limit: parseInt(limit),\n      offset: parseInt(offset),\n    });\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Get single transaction\nrouter.get('/:id', async (req, res, next): Promise<any> => {\n  try {\n    const result = await query(\n      'SELECT * FROM v_transaction_details WHERE transaction_id = $1',\n      [req.params.id]\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Transaction not found' });\n    }\n\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Update payment status\nrouter.patch('/:id/payment', authorize('admin', 'manager'), async (req, res, next) => {\n  try {\n    const { paymentStatus, paymentDate, paymentReference } = req.body;\n\n    const result = await query(\n      `UPDATE transaction \n       SET payment_status = $1, payment_date = $2, payment_reference = $3, updated_at = CURRENT_TIMESTAMP\n       WHERE id = $4\n       RETURNING *`,\n      [paymentStatus, paymentDate, paymentReference, req.params.id]\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Transaction not found' });\n    }\n\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/users.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\nimport bcrypt from 'bcrypt';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', authorize('admin', 'manager'), async (_req, res, next) => {\n  try {\n    const result = await query('SELECT id, email, first_name, last_name, role, location_id, is_active FROM \"user\" ORDER BY first_name, last_name');\n    res.json({ users: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', authorize('admin'), async (req, res, next) => {\n  try {\n    const { email, password, firstName, lastName, role, locationId } = req.body;\n    const passwordHash = await bcrypt.hash(password, 10);\n    const result = await query(\n      'INSERT INTO \"user\" (email, password_hash, first_name, last_name, role, location_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, first_name, last_name, role, location_id',\n      [email, passwordHash, firstName, lastName, role, locationId]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/routes/wastePickers.ts": "import { Router } from 'express';\nimport { query } from '../db';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nrouter.use(authenticate);\n\nrouter.get('/', async (req, res, next) => {\n  try {\n    const { search } = req.query;\n    let queryText = 'SELECT * FROM waste_picker WHERE is_active = true';\n    const params: any[] = [];\n\n    if (search) {\n      params.push(`%${search}%`);\n      queryText += ' AND (first_name ILIKE $1 OR last_name ILIKE $1 OR id_number ILIKE $1)';\n    }\n\n    queryText += ' ORDER BY first_name, last_name';\n\n    const result = await query(queryText, params);\n    res.json({ wastePickers: result.rows });\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.get('/:id', async (req, res, next): Promise<any> => {\n  try {\n    const result = await query('SELECT * FROM waste_picker WHERE id = $1', [req.params.id]);\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Waste picker not found' });\n    }\n    res.json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', authorize('admin', 'manager'), async (req, res, next) => {\n  try {\n    const { firstName, lastName, idNumber, phone, email, address, isAffiliated, bankName, bankAccount, paymentMethod } = req.body;\n    const result = await query(\n      `INSERT INTO waste_picker (first_name, last_name, id_number, phone, email, address, is_affiliated, bank_name, bank_account, payment_method)\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`,\n      [firstName, lastName, idNumber, phone, email, address, isAffiliated, bankName, bankAccount, paymentMethod]\n    );\n    res.status(201).json(result.rows[0]);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;",
  "backend/src/server.ts": "import express, { Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport morgan from 'morgan';\nimport { config } from './config';\nimport { healthCheck } from './db';\n\n// Import routes (will be created)\nimport authRoutes from './routes/auth';\nimport transactionRoutes from './routes/transactions';\nimport inventoryRoutes from './routes/inventory';\nimport reportRoutes from './routes/reports';\nimport locationRoutes from './routes/locations';\nimport materialRoutes from './routes/materials';\nimport wastePickerRoutes from './routes/wastePickers';\nimport apartmentRoutes from './routes/apartments';\nimport clientRoutes from './routes/clients';\nimport syncRoutes from './routes/sync';\nimport userRoutes from './routes/users';\n\nconst app = express();\n\n// Middleware\napp.use(helmet());\napp.use(cors({ origin: config.corsOrigin, credentials: true }));\napp.use(compression());\napp.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Health check endpoint\napp.get('/health', async (_req: Request, res: Response) => {\n  const dbHealthy = await healthCheck();\n  \n  res.status(dbHealthy ? 200 : 503).json({\n    status: dbHealthy ? 'healthy' : 'unhealthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    database: dbHealthy ? 'connected' : 'disconnected',\n  });\n});\n\n// API routes\nconst apiRouter = express.Router();\n\napiRouter.use('/auth', authRoutes);\napiRouter.use('/transactions', transactionRoutes);\napiRouter.use('/inventory', inventoryRoutes);\napiRouter.use('/reports', reportRoutes);\napiRouter.use('/locations', locationRoutes);\napiRouter.use('/materials', materialRoutes);\napiRouter.use('/waste-pickers', wastePickerRoutes);\napiRouter.use('/apartments', apartmentRoutes);\napiRouter.use('/clients', clientRoutes);\napiRouter.use('/sync', syncRoutes);\napiRouter.use('/users', userRoutes);\n\napp.use(config.apiPrefix, apiRouter);\n\n// 404 handler\napp.use((req: Request, res: Response) => {\n  res.status(404).json({\n    error: 'Not Found',\n    message: `Cannot ${req.method} ${req.url}`,\n  });\n});\n\n// Error handler\napp.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n  console.error('Error:', err);\n  \n  const statusCode = err.statusCode || err.status || 500;\n  const message = err.message || 'Internal Server Error';\n  \n  res.status(statusCode).json({\n    error: config.nodeEnv === 'production' ? 'Server Error' : err.name,\n    message: config.nodeEnv === 'production' && statusCode === 500 \n      ? 'An unexpected error occurred' \n      : message,\n    ...(config.nodeEnv === 'development' && { stack: err.stack }),\n  });\n});\n\n// Start server\nconst server = app.listen(config.port, () => {\n  console.log(`\ud83d\ude80 Server running on port ${config.port}`);\n  console.log(`\ud83d\udcdd API available at http://localhost:${config.port}${config.apiPrefix}`);\n  console.log(`\ud83c\udf0d Environment: ${config.nodeEnv}`);\n});\n\n// Graceful shutdown\nconst gracefulShutdown = (signal: string) => {\n  console.log(`\\n${signal} received, shutting down gracefully...`);\n  server.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n\n  setTimeout(() => {\n    console.error('Forcing shutdown after timeout');\n    process.exit(1);\n  }, 10000);\n};\n\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\nexport default app;"
}